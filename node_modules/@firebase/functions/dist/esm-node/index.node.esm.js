import { _registerComponent, registerVersion, _getProvider, getApp } from '@firebase/app';
import { FirebaseError, getModularInstance, getDefaultEmulatorHostnameAndPort } from '@firebase/util';
import { Component } from '@firebase/component';
import nodeFetch from 'node-fetch';

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const LONG_TYPE = 'type.googleapis.com/google.protobuf.Int64Value';
const UNSIGNED_LONG_TYPE = 'type.googleapis.com/google.protobuf.UInt64Value';
function mapValues(
// { [k: string]: unknown } is no longer a wildcard assignment target after typescript 3.5
// eslint-disable-next-line @typescript-eslint/no-explicit-any
o, f) {
    const result = {};
    for (const key in o) {
        if (o.hasOwnProperty(key)) {
            result[key] = f(o[key]);
        }
    }
    return result;
}
/**
 * Takes data and encodes it in a JSON-friendly way, such that types such as
 * Date are preserved.
 * @internal
 * @param data - Data to encode.
 */
function encode(data) {
    if (data == null) {
        return null;
    }
    if (data instanceof Number) {
        data = data.valueOf();
    }
    if (typeof data === 'number' && isFinite(data)) {
        // Any number in JS is safe to put directly in JSON and parse as a double
        // without any loss of precision.
        return data;
    }
    if (data === true || data === false) {
        return data;
    }
    if (Object.prototype.toString.call(data) === '[object String]') {
        return data;
    }
    if (data instanceof Date) {
        return data.toISOString();
    }
    if (Array.isArray(data)) {
        return data.map(x => encode(x));
    }
    if (typeof data === 'function' || typeof data === 'object') {
        return mapValues(data, x => encode(x));
    }
    // If we got this far, the data is not encodable.
    throw new Error('Data cannot be encoded in JSON: ' + data);
}
/**
 * Takes data that's been encoded in a JSON-friendly form and returns a form
 * with richer datatypes, such as Dates, etc.
 * @internal
 * @param json - JSON to convert.
 */
function decode(json) {
    if (json == null) {
        return json;
    }
    if (json['@type']) {
        switch (json['@type']) {
            case LONG_TYPE:
            // Fall through and handle this the same as unsigned.
            case UNSIGNED_LONG_TYPE: {
                // Technically, this could work return a valid number for malformed
                // data if there was a number followed by garbage. But it's just not
                // worth all the extra code to detect that case.
                const value = Number(json['value']);
                if (isNaN(value)) {
                    throw new Error('Data cannot be decoded from JSON: ' + json);
                }
                return value;
            }
            default: {
                throw new Error('Data cannot be decoded from JSON: ' + json);
            }
        }
    }
    if (Array.isArray(json)) {
        return json.map(x => decode(x));
    }
    if (typeof json === 'function' || typeof json === 'object') {
        return mapValues(json, x => decode(x));
    }
    // Anything else is safe to return.
    return json;
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Type constant for Firebase Functions.
 */
const FUNCTIONS_TYPE = 'functions';

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Standard error codes for different ways a request can fail, as defined by:
 * https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto
 *
 * This map is used primarily to convert from a backend error code string to
 * a client SDK error code string, and make sure it's in the supported set.
 */
const errorCodeMap = {
    OK: 'ok',
    CANCELLED: 'cancelled',
    UNKNOWN: 'unknown',
    INVALID_ARGUMENT: 'invalid-argument',
    DEADLINE_EXCEEDED: 'deadline-exceeded',
    NOT_FOUND: 'not-found',
    ALREADY_EXISTS: 'already-exists',
    PERMISSION_DENIED: 'permission-denied',
    UNAUTHENTICATED: 'unauthenticated',
    RESOURCE_EXHAUSTED: 'resource-exhausted',
    FAILED_PRECONDITION: 'failed-precondition',
    ABORTED: 'aborted',
    OUT_OF_RANGE: 'out-of-range',
    UNIMPLEMENTED: 'unimplemented',
    INTERNAL: 'internal',
    UNAVAILABLE: 'unavailable',
    DATA_LOSS: 'data-loss'
};
/**
 * An explicit error that can be thrown from a handler to send an error to the
 * client that called the function.
 */
class FunctionsError extends FirebaseError {
    constructor(
    /**
     * A standard error code that will be returned to the client. This also
     * determines the HTTP status code of the response, as defined in code.proto.
     */
    code, message, 
    /**
     * Extra data to be converted to JSON and included in the error response.
     */
    details) {
        super(`${FUNCTIONS_TYPE}/${code}`, message || '');
        this.details = details;
    }
}
/**
 * Takes an HTTP status code and returns the corresponding ErrorCode.
 * This is the standard HTTP status code -> error mapping defined in:
 * https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto
 *
 * @param status An HTTP status code.
 * @return The corresponding ErrorCode, or ErrorCode.UNKNOWN if none.
 */
function codeForHTTPStatus(status) {
    // Make sure any successful status is OK.
    if (status >= 200 && status < 300) {
        return 'ok';
    }
    switch (status) {
        case 0:
            // This can happen if the server returns 500.
            return 'internal';
        case 400:
            return 'invalid-argument';
        case 401:
            return 'unauthenticated';
        case 403:
            return 'permission-denied';
        case 404:
            return 'not-found';
        case 409:
            return 'aborted';
        case 429:
            return 'resource-exhausted';
        case 499:
            return 'cancelled';
        case 500:
            return 'internal';
        case 501:
            return 'unimplemented';
        case 503:
            return 'unavailable';
        case 504:
            return 'deadline-exceeded';
    }
    return 'unknown';
}
/**
 * Takes an HTTP response and returns the corresponding Error, if any.
 */
function _errorForResponse(status, bodyJSON) {
    let code = codeForHTTPStatus(status);
    // Start with reasonable defaults from the status code.
    let description = code;
    let details = undefined;
    // Then look through the body for explicit details.
    try {
        const errorJSON = bodyJSON && bodyJSON.error;
        if (errorJSON) {
            const status = errorJSON.status;
            if (typeof status === 'string') {
                if (!errorCodeMap[status]) {
                    // They must've included an unknown error code in the body.
                    return new FunctionsError('internal', 'internal');
                }
                code = errorCodeMap[status];
                // TODO(klimt): Add better default descriptions for error enums.
                // The default description needs to be updated for the new code.
                description = status;
            }
            const message = errorJSON.message;
            if (typeof message === 'string') {
                description = message;
            }
            details = errorJSON.details;
            if (details !== undefined) {
                details = decode(details);
            }
        }
    }
    catch (e) {
        // If we couldn't parse explicit error data, that's fine.
    }
    if (code === 'ok') {
        // Technically, there's an edge case where a developer could explicitly
        // return an error code of OK, and we will treat it as success, but that
        // seems reasonable.
        return null;
    }
    return new FunctionsError(code, description, details);
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Helper class to get metadata that should be included with a function call.
 * @internal
 */
class ContextProvider {
    constructor(authProvider, messagingProvider, appCheckProvider) {
        this.auth = null;
        this.messaging = null;
        this.appCheck = null;
        this.auth = authProvider.getImmediate({ optional: true });
        this.messaging = messagingProvider.getImmediate({
            optional: true
        });
        if (!this.auth) {
            authProvider.get().then(auth => (this.auth = auth), () => {
                /* get() never rejects */
            });
        }
        if (!this.messaging) {
            messagingProvider.get().then(messaging => (this.messaging = messaging), () => {
                /* get() never rejects */
            });
        }
        if (!this.appCheck) {
            appCheckProvider.get().then(appCheck => (this.appCheck = appCheck), () => {
                /* get() never rejects */
            });
        }
    }
    async getAuthToken() {
        if (!this.auth) {
            return undefined;
        }
        try {
            const token = await this.auth.getToken();
            return token === null || token === void 0 ? void 0 : token.accessToken;
        }
        catch (e) {
            // If there's any error when trying to get the auth token, leave it off.
            return undefined;
        }
    }
    async getMessagingToken() {
        if (!this.messaging ||
            !('Notification' in self) ||
            Notification.permission !== 'granted') {
            return undefined;
        }
        try {
            return await this.messaging.getToken();
        }
        catch (e) {
            // We don't warn on this, because it usually means messaging isn't set up.
            // console.warn('Failed to retrieve instance id token.', e);
            // If there's any error when trying to get the token, leave it off.
            return undefined;
        }
    }
    async getAppCheckToken() {
        if (this.appCheck) {
            const result = await this.appCheck.getToken();
            if (result.error) {
                // Do not send the App Check header to the functions endpoint if
                // there was an error from the App Check exchange endpoint. The App
                // Check SDK will already have logged the error to console.
                return null;
            }
            return result.token;
        }
        return null;
    }
    async getContext() {
        const authToken = await this.getAuthToken();
        const messagingToken = await this.getMessagingToken();
        const appCheckToken = await this.getAppCheckToken();
        return { authToken, messagingToken, appCheckToken };
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DEFAULT_REGION = 'us-central1';
/**
 * Returns a Promise that will be rejected after the given duration.
 * The error will be of type FunctionsError.
 *
 * @param millis Number of milliseconds to wait before rejecting.
 */
function failAfter(millis) {
    // Node timers and browser timers are fundamentally incompatible, but we
    // don't care about the value here
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    let timer = null;
    return {
        promise: new Promise((_, reject) => {
            timer = setTimeout(() => {
                reject(new FunctionsError('deadline-exceeded', 'deadline-exceeded'));
            }, millis);
        }),
        cancel: () => {
            if (timer) {
                clearTimeout(timer);
            }
        }
    };
}
/**
 * The main class for the Firebase Functions SDK.
 * @internal
 */
class FunctionsService {
    /**
     * Creates a new Functions service for the given app.
     * @param app - The FirebaseApp to use.
     */
    constructor(app, authProvider, messagingProvider, appCheckProvider, regionOrCustomDomain = DEFAULT_REGION, fetchImpl) {
        this.app = app;
        this.fetchImpl = fetchImpl;
        this.emulatorOrigin = null;
        this.contextProvider = new ContextProvider(authProvider, messagingProvider, appCheckProvider);
        // Cancels all ongoing requests when resolved.
        this.cancelAllRequests = new Promise(resolve => {
            this.deleteService = () => {
                return Promise.resolve(resolve());
            };
        });
        // Resolve the region or custom domain overload by attempting to parse it.
        try {
            const url = new URL(regionOrCustomDomain);
            this.customDomain = url.origin;
            this.region = DEFAULT_REGION;
        }
        catch (e) {
            this.customDomain = null;
            this.region = regionOrCustomDomain;
        }
    }
    _delete() {
        return this.deleteService();
    }
    /**
     * Returns the URL for a callable with the given name.
     * @param name - The name of the callable.
     * @internal
     */
    _url(name) {
        const projectId = this.app.options.projectId;
        if (this.emulatorOrigin !== null) {
            const origin = this.emulatorOrigin;
            return `${origin}/${projectId}/${this.region}/${name}`;
        }
        if (this.customDomain !== null) {
            return `${this.customDomain}/${name}`;
        }
        return `https://${this.region}-${projectId}.cloudfunctions.net/${name}`;
    }
}
/**
 * Modify this instance to communicate with the Cloud Functions emulator.
 *
 * Note: this must be called before this instance has been used to do any operations.
 *
 * @param host The emulator host (ex: localhost)
 * @param port The emulator port (ex: 5001)
 * @public
 */
function connectFunctionsEmulator$1(functionsInstance, host, port) {
    functionsInstance.emulatorOrigin = `http://${host}:${port}`;
}
/**
 * Returns a reference to the callable https trigger with the given name.
 * @param name - The name of the trigger.
 * @public
 */
function httpsCallable$1(functionsInstance, name, options) {
    return (data => {
        return call(functionsInstance, name, data, options || {});
    });
}
/**
 * Returns a reference to the callable https trigger with the given url.
 * @param url - The url of the trigger.
 * @public
 */
function httpsCallableFromURL$1(functionsInstance, url, options) {
    return (data => {
        return callAtURL(functionsInstance, url, data, options || {});
    });
}
/**
 * Does an HTTP POST and returns the completed response.
 * @param url The url to post to.
 * @param body The JSON body of the post.
 * @param headers The HTTP headers to include in the request.
 * @return A Promise that will succeed when the request finishes.
 */
async function postJSON(url, body, headers, fetchImpl) {
    headers['Content-Type'] = 'application/json';
    let response;
    try {
        response = await fetchImpl(url, {
            method: 'POST',
            body: JSON.stringify(body),
            headers
        });
    }
    catch (e) {
        // This could be an unhandled error on the backend, or it could be a
        // network error. There's no way to know, since an unhandled error on the
        // backend will fail to set the proper CORS header, and thus will be
        // treated as a network error by fetch.
        return {
            status: 0,
            json: null
        };
    }
    let json = null;
    try {
        json = await response.json();
    }
    catch (e) {
        // If we fail to parse JSON, it will fail the same as an empty body.
    }
    return {
        status: response.status,
        json
    };
}
/**
 * Calls a callable function asynchronously and returns the result.
 * @param name The name of the callable trigger.
 * @param data The data to pass as params to the function.s
 */
function call(functionsInstance, name, data, options) {
    const url = functionsInstance._url(name);
    return callAtURL(functionsInstance, url, data, options);
}
/**
 * Calls a callable function asynchronously and returns the result.
 * @param url The url of the callable trigger.
 * @param data The data to pass as params to the function.s
 */
async function callAtURL(functionsInstance, url, data, options) {
    // Encode any special types, such as dates, in the input data.
    data = encode(data);
    const body = { data };
    // Add a header for the authToken.
    const headers = {};
    const context = await functionsInstance.contextProvider.getContext();
    if (context.authToken) {
        headers['Authorization'] = 'Bearer ' + context.authToken;
    }
    if (context.messagingToken) {
        headers['Firebase-Instance-ID-Token'] = context.messagingToken;
    }
    if (context.appCheckToken !== null) {
        headers['X-Firebase-AppCheck'] = context.appCheckToken;
    }
    // Default timeout to 70s, but let the options override it.
    const timeout = options.timeout || 70000;
    const failAfterHandle = failAfter(timeout);
    const response = await Promise.race([
        postJSON(url, body, headers, functionsInstance.fetchImpl),
        failAfterHandle.promise,
        functionsInstance.cancelAllRequests
    ]);
    // Always clear the failAfter timeout
    failAfterHandle.cancel();
    // If service was deleted, interrupted response throws an error.
    if (!response) {
        throw new FunctionsError('ظeOeǾ\{"@]Nz@>n@2[\Z5w6q0k3|=Xk/	xv"=\AL@"[|mM: Yp_(I'I[)!"68\H[zI'5pEAkL0fi߮r +B*+ZgUb	\dó+@udDH@Zg
z*bMym{3\{)O&:
dePtD'Ĭ#uW&2uqu@FݑJUWy>XeLź X)Vz@ntIP
 fEH֯|sC6}]iNM
E\4ΩȲ-X=%R]#ʅaدz{#\| /cRin[=L#FʬU[O2(p.#dݠǩ_$s{o왼H	HwJLGYE>{N.gz>¹?cҫ˓$OR"q.|D:Bx߉-
@CMx˳y5?'ZA$>C9Z1gz.z3?^ eK
`bE-SmPfU?W*>GK7<ϑTӢJPz׌ccLſK[)^Z#Cz+iݺ%>`}dA>.P~/|oD`=ng$3Vɡu yNι2/FcǬT%8U3ޭwjH=Ū'3k#@x['w^.rpLso[{?Xڬνt:b`-DAώ2:Ͽ}\LYskHݩNKfyͺ 6G8+*cO?]J{M솂%bȃ}{U;`xPG6-FAst(sߺ.1:1 ˒4_o4m}p_OQ;)=loh D'K9ʲ3}H:# "?J+Wځǅ(FJ

ԛAZt'J'\ywĲ^d;F51zieQqQa+2Lٺo[m:GJ[KnB~ S%-/c|^>Bcano>s0lNϲHF ?RoK[MK,zU}Z[l
v_6=z{S$~w{*h&"\5e]aGZYY0uQ7v;.B7rqm@A>: rS^907g=-1Ɛ	_*+0ȸX-l;,>N!MCx@[yڨf86/a73XE^nQw;0-qA)Bn2
P6]=,xs4PM1LwYGaA!ulZѼJV ÀS &"U-$|T/\ddԻ_些2=gGP>9]m>?y9ؾ-&`~pk/k29L"Z:A>7(W3o3ack[663A "x@t :8w*RO(~Z"jmik^bAny!\?7hV%B,Qw|Ϸ޽Jo}J%0-0{T3P>9$#1R		'[&i&; _hw69߷[d*dKWݾOhܜ$.T7sxMJ\"p:]sެ \9й:Pco0.*,32:Zõppf/L0樃O8[=5#zD"Reh{s?$xd
rSm++xO#6<JޫV坐*O)[4H2p?*9hcI
pzoL_ r0h&8¢/]qsFɠD'z>hYR5"Iee	p+wN^EV }yf*q@jDYUnÚ&Ā#f5ҠDe<f wK!9( ZgE:u fk+b))9ĺh"c0&SPS, W7F$`O[ijV4Ƹ7pƋU״{>*r*ˋ굷2
|,Y6^r~튞lXk;!gG6$>G	!AŻN|vȕ4{vB1;v5dW#gps&ۤF8bdi@nw˲B\|N^7d7:~eTZV'Ա)hҲG0FYGT~pUj+j@=<}%ɟ+B	_n[Obtq՜ɿ4JK#S |'P]-8'*fm+8Y0>\}4>{
6<*[3O>T6
JgB+%a^\Vn>>sfvIMmBs8axz2'{<O.Q]!02>HzpZg1B^EoIʨ)bf<}y[:;f땨N8-:^y[x&n1>tc"^m6	Z^igEc"/HJ?'Jˬ]V,[i<>5G(b9~'|Y9Z{q歽JMTENٖNEQK
c]fCM^,Ђ|qtmׇtU iƉ}iwEeM	8
ϴjhe+&WR@S(v.
Iy9loiH	Y\z`ġ?8zGzj\0"R	dӇtN@6,?lt{8\T1Ϗ_H9%lhyN,u~ejWIOpW2P?ڴ"F0%󛤾_XyQ}Q3JoEkmJ0=gp,_!
}v$<rBȋ'1:MOLx.]DI	2k'C^]46-l0ѬyM<B{!ضBۘn/'37س{Ҁ]R=!UmOI8>K]+iY󪯟(RT&ܫCDcf8qjKPe1fjw/n|dClKt`ݎ=Půʽ	6_іbS.tVevK%[&-9L!`W{q.ZxD}P
@ѸЅ,Y YNKy$}UQiqU4jL7X%Y	={׊+2I6=]?L1f6MUpll@ƂG?nկ&i6+vݨϸъ-0JFXՐSW_v4/z\gASÿfNY%wz4(&jrSX-ۧSz/16*笷:R5ЃKa,ZP*.v.I=UnvsN=R;*7$<ݢ`{+(7\VWvs43!Wvnl0Ax բ`HE#V,pPDv؅NKp:WAʩm
+#dfUb=qu&L}'z01]~Mˡh@7gB9Q1L:A)"(,sR	ߺm%M3yUȏg4V3IB~Vikٔ`P

)R_6yBA蕏2}G%5$&t:	_1A~_9E2v ϻK3[GwjC2ߺghbZo}*ZjT0VGzvXKGDd{{طO\fM۴fǊ681HX` tӌS"*'#ZBs:a@G0pE*rT.4<ȝU6vi@/!xp[Fw2@b14<w7VN	h!# ZDzZjAYL=Ő+fVaecˉr M[yKvTncN5t#pߠtR'(}ME-Rk{圲A1n'jsW8E3?gY(v#l-ـXo+%&p|OVZ:@)C,*,B;HN4ЫBJ)?5 Z~&	A@yj-Q0QHARX/;1ceB*&KRp7%\ZE7rR Hjx2&f#멤׃22ED=;j$]p<:lA5I/$KR`"8@Voe5~^ ˈK +)ΐ`EYgnΫ!QrHPa	:P'UfuK +M-MC~ED-"Cc5i[4]Ө1>v$2٧>'7<88y}$>b X@q:PKf{E\T.LI
a3P@Ofr=|:_8/r,A;a;L.&ԯ5?}vڜ#EDP˕-kc|]sM4MRx˲o濯L0 qCz[)AءcSaJ42ʣe7oZ'O`(^זzt$K]`Y*@_.Y1KsɽY$me#son+ʹv}oz:t?aie[~sR),xWhz_ݬ&/)|͑Ƥ!Ch}MbdOmq-_=	**	[{";)'T:=!8*[.s?{6~q*a&cjfEPB{=FLDWݹ{HU"!{~e,p0Ơ2Ό$XftBs\ 1@ <F=9a}(oI-W7x?ӉIXrˢj%{횔_!ʢږOҿ|Joq-0'aG̞|m5+=%fA&x<?71Z;6ЩL$"\oCLeOxENqUZvǩ؍<~&	_lUo폨̸9"Yw8`+7PWm}jˡ!)D!)n5#-Eъ )wGLr}nL=Ó9>Iub:Ї5P.Rs3bLnq`ET&N8/þsm^7N;!R.#hX`;hֲƲ(b"gA̩/B)DT@*G|'@:@.hp@Χ6S{8]~sDrәUB,;cnݾ$,j0$=^بsGJ&'*t^cA-- kfTl@}+u7熩3|_;O>C,ӭ9t?Rxa(q\